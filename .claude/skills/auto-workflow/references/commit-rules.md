# コミットルール

## Semantic Commit Messages

```
<type>: <description>
```

| タイプ | 用途 | 例 |
|-------|------|-----|
| `feat` | 新機能（ユーザー向け） | `feat: ダッシュボード画面を追加` |
| `fix` | バグ修正（ユーザー向け） | `fix: ログアウト後のリダイレクトを修正` |
| `docs` | ドキュメント変更 | `docs: セットアップガイドを更新` |
| `style` | フォーマット等（機能変更なし） | `style: コードフォーマットを統一` |
| `refactor` | コード改善（機能変更なし） | `refactor: 認証ロジックをリファクタリング` |
| `test` | テスト追加・修正 | `test: ユーザー登録のテストを追加` |
| `chore` | ビルドタスク等の更新 | `chore: 依存関係を更新` |

## 注意点

- 簡潔で明確な説明（50文字以内目安）
- 1コミット = 1 Task（TaskCreateで作成される単位）

## Atomic Commit原則: 1 Task = 1 Commit

Task完了ごとに即コミットする。Taskは実装時に自然と適切な粒度に分解されるため、これがコミットの基準となる。

### 粒度の目安

```
✅ Task粒度（適切）:
- "UserServiceクラスを作成" → feat: UserServiceクラスを作成
- "ログインフォームにバリデーションを追加" → feat: ログインフォームにバリデーションを追加
- "UserServiceのユニットテストを追加" → test: UserServiceのユニットテストを追加

✗ 大きすぎる（複数Taskをまとめている）:
- "ユーザー認証機能を実装"（サービス + フォーム + テストが混在）
```

### コミット粒度の判断基準

**1つのコミット（= 1 Task）にすべき変更:**
- 1つのTaskで実装した全ファイル
- 複数ファイルだが同じTask（実装 + それに伴うimport追加等）

**分割すべき変更（別Taskにすべき）:**
- 新機能の実装 + バグ修正
- 複数の独立した機能追加
- リファクタリング + 新機能追加

### チェックリスト

- [ ] 1つのTaskの変更のみを含むか？
- [ ] コミットメッセージで変更内容を簡潔に説明できるか？
- [ ] このコミット単体でレビュー可能か？
