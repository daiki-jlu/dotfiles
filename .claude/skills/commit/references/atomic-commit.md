# Atomic Commit原則（CRITICAL）

## 重要性

- **レビュアビリティ**: 各コミットが独立して理解可能
- **リバート可能性**: 問題があれば特定のコミットだけを元に戻せる
- **デバッグ効率**: git bisectで問題の原因を特定しやすい

## 基本原則

### 1コミット = 1つの論理的変更

```
✅ 良い例:
- feat: 依存関係を追加
- feat: Buttonコンポーネントを実装
- test: Buttonコンポーネントのテストを追加

✗ 悪い例:
- feat: 初期環境構築（依存関係 + コンポーネント + テスト）
```

### 動作確認後に都度コミット

```bash
# ✅ 正しいアプローチ
npm install @heroicons/react
git add package.json package-lock.json
git commit -m "feat: Heroiconsライブラリを追加"

# コンポーネント実装後、最低限の動作を確認してコミット
git add src/components/Button.tsx
git commit -m "feat: Buttonコンポーネントを実装"

# テスト追加後、passを確認してコミット
git add src/components/Button.test.tsx
git commit -m "test: Buttonコンポーネントのテストを追加"
```

**重要**: バグだらけの状態でコミットしない。最低限正しく実装されている状態でコミットする。

## コミット粒度の判断基準

### 1つのコミットにすべき変更

- ✅ 1つのファイルの論理的な変更
- ✅ 複数ファイルだが同じ目的（import文の追加 + 使用箇所）

### 分割すべき変更

- ❌ 新機能の実装 + バグ修正
- ❌ 複数の独立した機能追加
- ❌ リファクタリング + 新機能追加

## チェックリスト

コミット前に確認：

- [ ] 1つの論理的変更のみを含むか？
- [ ] コミットメッセージで変更内容を簡潔に説明できるか？
- [ ] このコミット単体でレビュー可能か？

## まとめ

**タスク開始時点で論理的単位を計画**し、**実装が完了したら都度コミット（最低限動作する状態で）**する。後から分割しない。
